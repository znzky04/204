项目介绍 — Task A, Task B, Task C
Task A — 路线规划程序设计
任务描述
Task A要求我们设计并实现一个基于图数据结构的路线规划程序。程序需要支持用户输入起点城市、终点城市和若干旅游景点，输出一条访问所有指定景点后到达终点的路径，并且保证路径的总距离最短。

技术与库
编程语言：Java

核心Java标准库：

java.util包中的集合类（如ArrayList, HashMap）用于存储城市、景点和图的邻接表

java.io包用于读取CSV文件

java.nio.file包辅助文件操作

时间测量方面用System.nanoTime()进行性能记录

禁止使用第三方图论库，例如JGraphT等，所有图结构和算法均自行实现。

实现要求
设计城市（City）、景点（Attraction）和路网（Graph）等类，实现图的邻接表结构存储

加载并解析attractions.csv和roads.csv，建立完整图结构和景点到城市的映射

实现一个公共接口方法：

java
复制
List<String> route(String startingCity, String endingCity, List<String> attractions);
返回路径中访问的城市和景点顺序。

代码需符合面向对象设计原则，良好封装、模块化，易于维护扩展。

Task B — 图算法最短路径实现与评价
任务描述
基于Task A构建的图数据结构，实现最短路径算法，计算起点出发依次访问所有中间景点，最后到达终点的路线，总距离最短。

技术与库
基础同Task A，Java标准库实现

自行实现Dijkstra最短路径算法作为计算单条路径的重要工具

对多景点路径搜索采用贪心或多阶段路径规划算法（例如对景点顺序的穷举/启发式搜索）

实现要求
计算并展示3个示例路径：

从 Houston TX 到 Philadelphia PA，无需中途访问景点

从 Philadelphia PA 到 San Antonio TX，需访问 Hollywood Sign

从 San Jose CA 到 Phoenix AZ，中间访问 Liberty Bell 和 Millennium Park

对算法时间复杂度（一般为 O(E log V)，其中E为边数，V为顶点数）及空间复杂度进行理论分析

说明算法是否保证全局最优，探讨可能的改进方案。

Task C — 排序算法性能评测
任务描述
实现并测试三种排序算法：插入排序、快速排序、归并排序，比较它们在不同数据集上的性能表现。

技术与库
Java语言实现，不调用任何排序内置库函数，完全自定义算法代码

使用Java中System.nanoTime()做精确性能测试

对以下四种数据集进行排序对比：

1000places_sorted.csv - 包含1000个已按字母顺序(A-Z)排序的地点名称，每行一个

1000places_random.csv - 包含1000个随机顺序的地点名称，每行一个

10000places_sorted.csv - 包含10000个已按字母顺序(A-Z)排序的地点名称，每行一个

10000places_random.csv - 包含10000个随机顺序的地点名称，每行一个

实现要求
输出不同算法在四类数据上的运行时间，采用表格形式呈现测试结果

分析排序算法在以下方面的优劣特点：
- 输入规模对性能的影响（1000 vs 10000）
- 输入有序性对性能的影响（有序 vs 随机）
- 在处理重复值时的稳定性
- 空间复杂度及内存使用限制

归纳总结各算法的适用场景及最佳用例。

是否符合课程要求
项目全部使用Java自定义实现，无第三方图论或排序库，符合课程禁止使用高级库的要求

充分体现面向对象设计，符合课程学习目标

使用指定数据集，完成指定测试示例，满足任务设计规范

对算法复杂度作理论分析，展开性能测试与对比

代码模块化，便于后续维护与功能扩展。

项目的详细预期结果
程序能正确读取并解析CSV数据，将城市和旅游景点构成图

实现的路径规划功能能输出最短路径方案和总距离，包含起点、景点访问顺序和终点

排序算法性能数据采用表格形式呈现，快速排序在大数据集表现优越，插入排序在小规模几乎有序数据集表现较好

体现面向对象设计的类结构清晰，代码注释完整，满足课程代码质量标准。