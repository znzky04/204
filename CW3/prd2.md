✅ 优化后的项目介绍（专注 Task A、B、C，供 AI 编程使用）
项目介绍：美国路线规划与排序算法性能评估系统（Java实现）
🔷 Task A — 路线规划程序设计
🎯 任务描述
本任务要求设计并实现一个基于图数据结构的路线规划程序。用户输入起点城市、终点城市及若干旅游景点后，系统需输出一条路径，访问所有指定景点后到达终点，且路径总距离最短。

🛠️ 技术要求
编程语言：Java

标准库使用（禁止使用第三方图论库如JGraphT）：

java.util：用于集合（如 ArrayList, HashMap）表示城市、景点及图结构；

java.io：读取 CSV 文件；

java.nio.file：辅助文件操作；

System.nanoTime()：用于算法性能测试。

🧱 类设计要求（面向对象）
需设计以下核心类（可自行扩展）：

City：城市名称、州缩写；

Attraction：景点名称及所属城市；

Graph：图的邻接表存储结构；

RoutePlanner：主逻辑类，负责路径搜索。

🧩 数据结构
景点数据（attractions.csv）：使用 Map<String, City> 或 Map<String, String> 映射景点名到城市名；

道路数据（roads.csv）：使用 Map<City, List<Neighbor>> 构建图的邻接表。

🔁 接口定义
java
复制
编辑
List<String> route(String startingCity, String endingCity, List<String> attractions);
说明：返回访问顺序中的城市与景点名称，顺序排列。返回类型可为 List<String>，或自定义类封装输出结构。

🔷 Task B — 最短路径图算法实现与评估
🎯 任务描述
基于 Task A 建立的图结构，实现在访问所有中间景点的前提下从起点到终点的最短路径算法。

🧠 核心算法
单次最短路径采用自行实现的 Dijkstra 算法；

多景点访问路径：

可采用贪心策略、回溯穷举或近似 TSP（旅行商）算法；

示例方案为"起点 + 所有景点 + 终点"之间两两最短路径的预处理 + 启发式搜索。

📊 测试用例（必须展示输出路径和总距离）：
Houston TX ➝ Philadelphia PA（无中途景点）

Philadelphia PA ➝ San Antonio TX，需访问：Hollywood Sign

San Jose CA ➝ Phoenix AZ，需访问：Liberty Bell 和 Millennium Park

📈 复杂度分析
Dijkstra算法：时间复杂度 O(E log V)（使用优先队列实现），空间复杂度 O(V)。

多景点路径搜索：若穷举全排列为 O(n!)，可考虑启发式改进。

🌐 最优性分析
若使用穷举法或启发式TSP路径，结果可能非全局最优；

可探讨改进方法（例如使用 A* 或动态规划方法改写）。

🔷 Task C — 排序算法性能评测
🎯 任务描述
实现并测试三种排序算法：插入排序、快速排序、归并排序，并比较它们在不同规模和有序程度的数据集上的性能。

📦 数据集（均为CSV，每行一个名称）：
1000places_sorted.csv：1000条已排序地点名称

1000places_random.csv：1000条随机顺序

10000places_sorted.csv：10000条已排序

10000places_random.csv：10000条随机顺序

🧪 测试方式
使用 System.nanoTime() 测量运行时间；

不使用 Arrays.sort() 等内建排序方法；

输出格式采用如下表格：

mathematica
复制
编辑
| Dataset                  | Insertion Sort (ms) | Quick Sort (ms) | Merge Sort (ms) |
|--------------------------|---------------------|------------------|------------------|
| 1000places_sorted        |                     |                  |                  |
| 1000places_random        |                     |                  |                  |
| 10000places_sorted       |                     |                  |                  |
| 10000places_random       |                     |                  |                  |
📊 分析重点：
有序 vs 随机：插入排序在已排序数据上接近线性性能；

小数据 vs 大数据：快速排序和归并排序对大数据集更高效；

重复值处理：归并排序、插入排序为稳定排序，快速排序非稳定；

空间复杂度：插入排序 O(1)，快速排序 O(log n)，归并排序 O(n)。

✅ 项目约束与规范遵守
全部代码需使用 Java 实现，不允许使用如 JGraphT 等第三方库；

所有排序和图论算法需自行实现；

程序模块化设计，符合面向对象开发原则；

程序必须能正确解析 CSV 文件，构建图结构并返回最短路径；

所有测试需使用指定数据集，输出路径与性能评估清晰呈现；

满足课程对于算法分析、类结构、性能评估等各项标准。


🖼️ JavaFX 可视化扩展要求（适用于 Task A & B）
🎯 目标
通过 JavaFX 图形界面，实现用户输入城市、景点等参数后，动态展示搜索过程和最终路径结果。帮助用户直观理解路径规划过程与图结构。界面应尽量简洁、交互友好。

📌 Task A&B 可视化功能要求
1. 📍 用户输入界面
使用 JavaFX 的 TextField、ComboBox 或 ListView 组件构建输入区域：

起点城市选择；

终点城市选择；

多选景点列表；

"开始规划"按钮。

2. 🧭 地图或图结构展示
使用 Canvas 或 Pane 自定义画布绘制城市（节点）和道路（边）：

城市用圆点/标签表示；

道路用直线连接；

**节点布局策略：** 由于缺少地理坐标，可采用**随机分布加最小间距**、**简化网格布局**或**自定义布局算法**来确定城市节点在画布上的位置。

**可视化内容：** 推荐绘制**所有**城市节点（用默认颜色表示），并用**醒目颜色（如红色）高亮显示最终计算出的最短路径的边**。景点城市节点可用**特殊颜色或形状**标记。

3. 📢 输出展示与反馈
以 Label 或 TextArea 显示路径顺序与总距离；

可加入"清除结果"按钮，重置输入；

**用户反馈：**
  - 在状态栏（如 `statusLabel`）或通过弹窗 (`Alert`) 显示用户友好的提示信息，例如："请选择起点和终点"、"未能找到路径"、"数据加载中..."、"路线规划中..."等。
  - 在执行耗时操作（如加载数据、规划路径）时，应**禁用相关按钮**并提供**加载状态**指示（如状态栏文本或 `ProgressBar`）。

✅ 示例布局参考：
less
复制
编辑
+-----------------------------------------------------------+
| 起点：[ComboBox]  终点：[ComboBox]                       |
| 景点选择：[ListView 多选]                                |
| [开始规划按钮]                                            |
+-------------------------+---------------------------------+
|                         |                                 |
|        地图画布         |    路径输出 / 距离显示区域      |
|     (Pane / Canvas)     |    TextArea + Label             |
|                         |                                 |
+-------------------------+---------------------------------+
🧠 可选增强（不强制）：
鼠标悬停显示城市名称；

可缩放视图；

**动画效果：** 动画显示**最终路径的生成过程**（例如，路径上的边依次高亮），而非复杂的算法搜索步骤模拟。基础可使用 `Timeline` 或 `PathTransition`。

**地图交互：** 允许用户在地图画布上**点击城市节点**，将其设置为起点/终点，或添加到待访问景点列表。

🔄 简化版可视化流程逻辑
加载 CSV 文件，构建图结构；

JavaFX GUI 提供用户选择输入项；

点击按钮后调用 route(...) 方法；

返回的路径作为绘图参数，渲染节点与路径；

控件输出距离与顺序信息。


🧰 技术栈和建议类划分
推荐组件类结构：
MainApp：JavaFX 应用入口；

RoutePlannerUI：构建主界面；

GraphPane：自定义地图绘图类（继承 Pane）；

Controller：处理按钮点击与数据交互；

可共用核心类：City, Graph, RoutePlanner 等。

推荐用法：
UI 与算法部分解耦，算法完成后只将结果传入可视化部分；

不建议动态动画算法过于复杂，保持简洁即可。

🧠 最后提示
JavaFX 可视化是加分项或功能亮点，但保持简单清晰才是关键。项目重在：

完成基础功能；

符合面向对象原则；

结构清楚，代码可维护；

有图形界面但不需要商业级精美。

**用户反馈处理：** Controller 类应负责处理用户输入验证、调用算法，并将成功/失败/加载状态反馈给 UI 组件。

推荐用法：
UI 与算法部分解耦，算法完成后只将结果传入可视化部分；

不建议动态动画算法过于复杂，保持简洁即可。